## 写在前面

基础部分讲述的内容，是几乎所有Mod都会频繁使用的、较为容易实现的特性。

建议读者在阅读完绪论后，对于初级部分的每一部分都加以阅读。

## 配置工作环境

解压在上一部分，也就是绪论中提到的下载到的文件，进入该目录，也就是工作环境的根目录。

如果你使用的是Linux或者Mac OS X，在该目录下运行命令：

```
./gradlew setupDecompWorkspace
```

如果你使用的是Microsoft Windows，则运行：

```
gradlew.bat setupDecompWorkspace
```

后面的所有类似命令、都将描述的是在Linux或者Mac OS X的运行方式，如果是Microsoft Windows用户请将后面的所有命令中的`./gradlew`替换成`gradlew.bat`，教程不再赘述。

可以通过添加参数的方式设置代理，`<host>`表示代理服务器的地址，`<port>`表示开放代理的端口。

使用socks代理的方式：

```
./gradlew setupDecompWorkspace -DsocksProxyHost=<host> -DsocksProxyPort=<port>
```

使用https代理的方式：

```
./gradlew setupDecompWorkspace -Dhttps.proxyHost=<host> -Dhttps.proxyPort=<port>
```

使用http代理的方式：

```
./gradlew setupDecompWorkspace -Dhttp.proxyHost=<host> -Dhttp.proxyPort=<port>
```

因为资源大多在国外，所以可能要等待一段漫长的时间（包括下面的两条命令）。建议在网络状况好的地方运行此命令，以配置开发环境，并获取反编译过的Minecraft源代码。如果有条件，建议使用国外的代理。

最后如果出现`BUILD SUCCESSFUL`字样，就代表你第一步的配置成功了，以下所有需要用到`./gradlew`的运行结果都以`BUILD SUCCESSFUL`字样为成功的标志，如果出现了`BUILD FAILED`字样，那么代表尚未成功，可以重新运行相同的命令尝试，如果还是不可以，可以尝试使用上面提到的使用代理的模式。

如果你使用Eclipse作为你的IDE，请在上面的命令运行完成后运行命令：

```
./gradlew eclipse
```

如果你使用IntellijIDEA（使用IDEA的异端→_→）的话：

```
./gradlew idea
```

使用代理的方式同上。

然后打开IDE，将工程目录切换到这个目录，如果配置成功，IDE会注意到这个目录存在一个工程，并自动找到刚刚配置的这个Mod工程的源代码和资源文件的位置。

默认配置中，Mod工程的源代码在目录`src/main/java`下，而Mod工程的资源文件（如图片、模型等）在目录`src/main/resources`下。读者应该会发现在Mod源代码中有一个`com.example.examplemod`的包，那个是测试用的，删掉就可以了。

## 运行、构建和发布Mod的方法

如果你想构建并发布你的Mod，运行下面的命令：

```
./gradlew build
```

这样根目录下的`build/libs/`里会有一个jar包，那便是你构建完成的Mod文件。

如果想要运行客户端，运行：

```
./gradlew runClient
```

如果想要运行服务端，运行：

```
./gradlew runServer
```

客户端和服务端的运行文件将在根目录的`eclipse`文件夹中。

上面三个命令在非特殊情况下，强烈建议添加`--offline`参数，阻止与外界网络的连接，即对国外的资源的访问，以提高速度。

当然，你也可以在你的IDE中运行、或者调试你的Mod。Forge在针对IDE配置的时候，已经添加了相关的运行选项。

## Forge是如何管理工程的

很明显，Mod的管理、构建都十分复杂，所以Forge使用了一个被称为[Gradle](https://gradle.org/)的工具，还通过编写插件的方式对其进行了[修改](https://github.com/MinecraftForge/ForgeGradle)。Gradle本身是一个比较强大的工程构建工具，它本身集成了很多的编译、构建选项，却又十分简单（相对[Maven](https://maven.apache.org/)来说）。

在你的根目录下应该有一个文件名为`bulid.gradle`的文件（为了节省篇幅，这里删掉了所有的注释）：

**`build.gradle:`**

```
plugins {
	id "net.minecraftforge.gradle.forge" version "2.0.2"
}

version = "1.0"
group= "com.yourname.modid"
archivesBaseName = "modid"

minecraft {
	version = "1.8.9-11.15.1.1722"
	runDir = "run"
	
	mappings = "snapshot_20141130"
}

dependencies {

}

processResources
{
	inputs.property "version", project.version
	inputs.property "mcversion", project.minecraft.version

	from(sourceSets.main.resources.srcDirs) {
	    include 'mcmod.info'
	            
	    expand 'version':project.version, 'mcversion':project.minecraft.version
	}
	    
	from(sourceSets.main.resources.srcDirs) {
	    exclude 'mcmod.info'
	}
}
```

这里，我们找到其中的三行：

**`build.gradle（部分）:`**

```
version = "1.0"
group= "com.yourname.modid"
archivesBaseName = "modid"
```

并更改掉它：

**`build.gradle（部分）:`**

```
version = "1.0.0"
group = "com.github.ustc_zzzz"
archivesBaseName = "fmltutor"
```

`version`表示该Mod的版本。关于版本的设置，可以参照一个GitHub推荐的，被称为[语义化版本](http://semver.org/lang/zh-CN/)的标准（[英文原版](http://semver.org/)），按照这个标准，作为第一个正式版本，显然应该是1.0.0。

`group`表示组id，建议使用Java包命名规范，比如如果你这个项目所在网站为`www.example.com`，那么包名建议为：

```
com.example.<your_username>.<your_project_name>
```

比如本教程的所有代码都在这个包下：

```
com.github.ustc_zzzz.fmltutor
```

当然如果没有网站，也可以直接使用用户名：

```
<your_username>.<your_project_name>
```

比如对于本教程的代码，可以这样命名：

```
ustc_zzzz.fmltutor
```

当然，也有直接以Mod名称作为包命名的，等等。

总而言之，包的命名以不冲突为前提。

`archivesBaseName`表示生成的Mod包使用的名称，Mod包使用的文件名是“名称+横线+版本号.jar”，这里就是`fmltutor-1.0.jar`。

Gradle本身有一个详细的[User Guide](https://docs.gradle.org/current/userguide/userguide)，如果读者对进一步的配置感兴趣，可以仔细阅读。

对于Mod进一步的配置，我们会在下一部分中提及。
