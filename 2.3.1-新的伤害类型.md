## DamageSource

原版提供了一个`DamageSource`类，并且预置了一些常用的`DamageSource`：

* `public static DamageSource inFire;` <br> 当站在火中时产生
* `public static DamageSource lightningBolt;` <br> 当遭雷劈时产生
* `public static DamageSource onFire;` <br> 当着火时产生
* `public static DamageSource lava;` <br> 当在岩浆中产生
* `public static DamageSource inWall;` <br> 当被方块窒息时产生
* `public static DamageSource drown;` <br> 当被水窒息时产生
* `public static DamageSource starve;` <br> 当饥饿值为零时产生
* `public static DamageSource cactus;` <br> 当被仙人掌刺伤时产生
* `public static DamageSource fall;` <br> 当受到跌落伤害时产生
* `public static DamageSource outOfWorld;` <br> 当跌落出这个世界时产生
* `public static DamageSource generic;` <br> 当死亡原因未知时产生
* `public static DamageSource magic;` <br> 当受到有伤害效果药水伤害时产生
* `public static DamageSource wither;` <br> 当被凋灵效果伤害时产生
* `public static DamageSource anvil;` <br> 当头顶铁砧时产生
* `public static DamageSource fallingBlock;` <br> 当头顶掉落的方块时产生

当希望对实体产生对应伤害时，就可以通过调用实体的`attackEntityFrom`方法，比如下面的例子：

    player.attackEntityFrom(DamageSource.lightningBolt, 8.0F);

意思就是对装\*过度（误）的玩家产生八滴血的雷劈伤害。

## 创造一个新的DamageSource

我们注意到，`DamageSource`类只有一个构造方法参数：

    public DamageSource(String damageTypeIn)

这个参数就是`DamageSource`的类型，决定着玩家死亡后会输出什么样的信息。

我们打开Minecraft原版的zh_CN.lang文件：

    ...
    death.attack.indirectMagic.item=%1$s 被 %2$s 用 %3$s 杀死了
    death.attack.lava=%1$s 试图在岩浆里游泳
    death.attack.lava.player=%1$s 在逃离 %2$s 时试图在岩浆里游泳
    death.attack.lightningBolt=%1$s 被闪电击中
    death.attack.magic=%1$s 被魔法杀死了
    death.attack.mob=%1$s 被 %2$s 杀死了
    death.attack.onFire=%1$s 被烧死了
    death.attack.onFire.player=%1$s 在试图与 %2$s 战斗时被烤的酥脆
    death.attack.outOfWorld=%1$s 掉出了这个世界
    death.attack.player=%1$s 被 %2$s 杀死了
    death.attack.player.item=%1$s 被 %2$s 用 %3$s 杀死了
    death.attack.starve=%1$s 饿死了
    death.attack.thorns=%1$s 在试图伤害 %2$s 时被杀
    death.attack.thrown=%1$s 被 %2$s 给砸死了
    death.attack.thrown.item=%1$s 被 %2$s 用 %3$s 给砸死了
    death.attack.wither=%1$s 凋零了
    ...

换言之，玩家死亡收到的信息，就是`death.attack.<damageTypeIn>`，或者`death.attack.<damageTypeIn>.item`。

我们新建这样一个事件：

**`src/main/java/com/github/ustc_zzzz/fmltutor/common/EventLoader.java（部分）:`**

        @SubscribeEvent
        public void onEntityInteract(EntityInteractEvent event)
        {
            EntityPlayer player = event.entityPlayer;
            if (player.isServerWorld() && event.target instanceof EntityPig)
            {
                EntityPig pig = (EntityPig) event.target;
                ItemStack stack = player.getCurrentEquippedItem();
                if (stack != null && (stack.getItem() == Items.wheat || stack.getItem() == Items.wheat_seeds))
                {
                    player.attackEntityFrom((new DamageSource("byPig")).setDifficultyScaled().setExplosion(), 8.0F);
                    player.worldObj.createExplosion(pig, pig.posX, pig.posY, pig.posZ, 2.0F, false);
                    pig.setDead();
                }
            }
        }

并在语言文件中加上：

**`src/main/resources/assets/fmltutor/lang/en_US.lang（部分）:`**

	death.attack.byPig=%s was dead because of a pig! 

**`src/main/resources/assets/fmltutor/lang/zh_CN.lang（部分）:`**

	death.attack.byPig=%s被猪弄死了！ 

读者应该能够看明白，这段代码的作用就是当玩家向猪试图喂食小麦或者小麦种子的时候，因为喂错饲料而发怒（误）的那头猪会Boom，并给玩家一定的伤害。

## DamageSource的属性

刚刚读者可能已经注意到了，我们为这个`DamegeSource`赋予了两个属性：

* `setDefficultyScaled`方法设置的属性表示受到的伤害随着难度的变化而变化。
* `setExplosion`方法设置的属性表示该伤害由爆炸造成，爆炸保护附魔会起到作用。

除此之外，还可以设置`DamageSource`的其他属性：

* `setDamageBypassesArmor`设置伤害不会因为盔甲的保护而折减。
* `setDamageAllowedInCreativeMode`设置创造模式同样会受到伤害。
* `setDamageIsAbsolute`设置伤害是绝对的，不会受到附魔、药水效果等影响。
* `setFireDamage`设置伤害由火焰造成，火焰保护附魔会起到作用。
* `setMagicDamage`设置伤害是由药水造成的。
* `setProjectile`设置伤害由弹射物造成，弹射物保护附魔会起到作用。
