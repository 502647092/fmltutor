## 制作一个物品一共分几步

制作一个物品一共分三步：

1. 创建一个物品
2. 实例化并注册这个物品
3. 为这个物品添加模型和材质

Minecraft中，使用八个金锭和一个苹果可以创造一个金苹果，那我们是不是可以创造一个金蛋呢，这一次教程会一步一步地带着你完成制作新物品的全过程。

## 创建一个物品

如果读者翻看了`net.minecraft.item`包，想必就会发现你在Minecraft中遇到的各种物品，都继承了`Item`类，那很明显，我们制作的物品也要继承这个类。

新建一个包`com.github.ustc_zzzz.fmltutor.item`，在其中创建一个类`ItemGoldenEgg`：

**`src/main/java/com/github/ustc_zzzz/fmltutor/item/ItemGoldenEgg.java:`**

```java
package com.github.ustc_zzzz.fmltutor.item;

import net.minecraft.item.Item;

public class ItemGoldenEgg extends Item
{
    public ItemGoldenEgg()
    {
        super();
        this.setUnlocalizedName("goldenEgg");
    }
}
```

这里的`setUnlocalizedName`方法为该物品添加了一个非本地化的名称，该名称为“`item.`”+设置的名称，比如这里就是`item.goldenEgg`，这个非本地化名称，与本地化和国际化有关，在后面的部分我们会讲到。**非本地化名称尽量使用小写驼峰式写法，即第一个词以小写字母开始，第二个词开始首字母大写，中间不使用任何符号分隔**。

## 实例化并注册这个物品

在`CommonProxy`类中添加下面的代码：

**`src/main/java/com/github/ustc_zzzz/fmltutor/common/CommonProxy.java（部分）:`**

```java
    public void preInit(FMLPreInitializationEvent event)
    {
        new ItemLoader(event);
    }
```

新建一个类`ItemLoader`：

**`src/main/java/com/github/ustc_zzzz/fmltutor/item/ItemLoader.java:`**

```java
package com.github.ustc_zzzz.fmltutor.item;

import net.minecraft.item.Item;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.registry.GameRegistry;

public class ItemLoader
{
    public static Item goldenEgg = new ItemGoldenEgg();

    public ItemLoader(FMLPreInitializationEvent event)
    {
        register(goldenEgg, "golden_egg");
    }

    private static void register(Item item, String name)
    {
        GameRegistry.registerItem(item, name);
    }
}
```

新建一个类进行初始化的原因是当你的物品越来越多，如果所有的注册过程都直接在`CommonProxy`类中进行，随着注册的对象越来越多，这些注册的对象会越来越难以管理。换句话说，这体现了代码模块化的原则。

首先，我们要实例化这个物品：

**`src/main/java/com/github/ustc_zzzz/fmltutor/item/ItemLoader.java（部分）:`**

```java
    public static Item goldenEgg = new ItemGoldenEgg();
```

然后，我们来到了这块的重点，注册这个物品：

**`src/main/java/com/github/ustc_zzzz/fmltutor/item/ItemLoader.java（部分）:`**

```java
        GameRegistry.registerItem(item, name);
```

`GameRegistry`是Forge提供的一个用来注册物品、方块、合成表、烧炼规则等各种常见内容的类，比如下面的用于注册的方法我们在后面都会遇到并加以讲解：

* `registerBlock`方法用于注册方块
* `registerFuelHandler`方法用于注册燃料
* `registerItem`方法用于注册物品
* `registerTileEntity`方法用于注册TileEntity（后面会讲到什么是TileEntity）
* `registerWorldGenerator`方法用于注册世界生成器以生成不同的世界
* `addRecipe`方法和`addShapedRecipe`方法用于注册合成表
* `addSmelting`方法用于注册物品烧炼规则

很明显，这个方法需要两个参数：

* 第一个参数就是这个物品，不做过多解释
* 第二个参数就是这个物品的id。物品id，包括后面的方块id，是一个用来标识物品的字符串。**同一个Mod下的物品id不能相同**。

我们这里通过参数提供物品的id。**id请尽量使用小写字母加下划线**，有的Mod使用驼峰式，这样的好处是把物品的非本地化名称和物品id设置成相同的，**但是我们不推荐这样的做法**。

现在不管是在服务端，还是在客户端，Forge都会在`preInit`阶段，运行到`ItemLoader`类中的构造函数，也就是实例化一个物品，并注册它。

现在运行客户端，运行命令：

```
/give @a fmltutor:golden_egg
```

玩家的手上便多了一个新的物品。

## 为这个物品添加模型和材质

可以看到，你手上的物品，现在还什么都没有，只是一个两种颜色交替的方块，这是因为你没有添加模型和材质。模型的作用是保证你手里的物品是一个扁平的长方体，而材质的作用，就是给这个长方体上色。

首先，新建一个文件夹：`src/main/resources/assets/fmltutor/models/item`，并在其中新建一个文件：`golden_egg.json`：

**`src/main/resources/assets/fmltutor/models/item/golden_egg.json:`**

```json
{
    "parent": "builtin/generated",
    "textures": {
        "layer0": "fmltutor:items/golden_egg"
    },
    "display": {
        "thirdperson": {
            "rotation": [ -90, 0, 0 ],
            "translation": [ 0, 1, -2 ],
            "scale": [ 0.55, 0.55, 0.55 ]
        },
        "firstperson": {
            "rotation": [ 0, -135, 25 ],
            "translation": [ 0, 4, 2 ],
            "scale": [ 1.7, 1.7, 1.7 ]
        }
    }
}
```

当然，这里的`fmltutor`就是Mod id，`golden_egg`就是你的物品id。

这个json的文件，就是这个物品的模型，这个文件的内容解释起来极其复杂，这也不是教程负责的介绍内容，直接抄下来就好了，但是有的地方是显而易见的：

**`src/main/resources/assets/fmltutor/models/item/golden_egg.json（部分）:`**

```json
    "textures": {
        "layer0": "fmltutor:items/golden_egg"
    },
```

这一部分告诉我们的是这个物品材质的位置，也就是`fmltutor:items/golden_egg`，很明显，我们需要建立一个材质文件。这里使用的是16x16的材质文件（当然Minecraft也支持尺寸更大如32x32的材质文件，不过建议还是使用16x16的），新建文件夹`src/main/resources/assets/fmltutor/textures/items`，把制作完成的golden_egg.png放入（其实是我照着鸡蛋的原图嗐改的=_=||）：

**`src/main/resources/assets/fmltutor/textures/items/golden_egg.png:`**

![golden_egg](resources/golden_egg.png)

所有模型和材质都准备好了，现在需要做的，就是**让Minecraft知道你准备的模型和材质**了。

修改`ItemLoader`类的内容：

**`src/main/java/com/github/ustc_zzzz/fmltutor/item/ItemLoader.java:`**

```java
package com.github.ustc_zzzz.fmltutor.item;

import net.minecraft.client.resources.model.ModelResourceLocation;
import net.minecraft.item.Item;
import net.minecraftforge.client.model.ModelLoader;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.registry.GameData;
import net.minecraftforge.fml.common.registry.GameRegistry;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ItemLoader
{
    public static Item goldenEgg = new ItemGoldenEgg();

    public ItemLoader(FMLPreInitializationEvent event)
    {
        register(goldenEgg, "golden_egg");
    }

    @SideOnly(Side.CLIENT)
    public static void registerRenders()
    {
        registerRender(goldenEgg);
    }

    private static void register(Item item, String name)
    {
        GameRegistry.registerItem(item, name);
    }

    @SideOnly(Side.CLIENT)
    private static void registerRender(Item item)
    {
        String name = GameData.getItemRegistry().getNameForObject(item).toString();
        ModelLoader.setCustomModelResourceLocation(item, 0, new ModelResourceLocation(name, "inventory"));
    }
}
```

我们来看这一段：

**`src/main/java/com/github/ustc_zzzz/fmltutor/item/ItemLoader.java（部分）:`**

```java
    @SideOnly(Side.CLIENT)
    private static void registerRender(Item item)
    {
        String name = GameData.getItemRegistry().getNameForObject(item).toString();
        ModelLoader.setCustomModelResourceLocation(item, 0, new ModelResourceLocation(name, "inventory"));
    }
```

Forge提供了`ModelLoader`类用于加载和处理模型，其`setCustomModelResourceLocation`方法有三个参数：

* 第一个参数是要被注册的物品。
* 第二个参数是这个物品的Metadata。Metadata是一个用于区分同一个物品或方块的不同状态的数据，比如钟表的十六种状态、羊毛的十六种颜色，在后面的部分会讲到Metadata，默认为零就好了。
* 第三个参数就是这个物品模型的资源位置了，资源位置是类`ModelResourceLocation`的一个实例，它用于描述一个模型，在后面我们还会比较常用到这个类的。

Minecraft通过在类`ModelResourceLocation`的构造函数中送入若干个字符串标注资源位置。比如这里，我们通过`GameData`类获取这个被注册的物品的名字、和对应的Mod id的拼合，也就是`fmltutor:golden_egg`。有了这个物品资源位置，Minecraft就会从`assets.fmltutor.models.item`下找到一个文件`golden_egg.json`，并读取这个文件加载物品模型。

关于资源位置的解释：

* `fmltutor`就是Mod id，这告诉游戏应该在`assets.fmltutor`包下找到这个资源。
* `golden_egg`就是资源名称，这告诉游戏这个资源就是`golden_egg.json`。

当然，上面已经提到了，`golden_egg.json`模型文件里已经包含了材质的信息。

`@SideOnly`注解的作用是注解这一方法、类等只作用于客户端或服务端。很明显，对于模型和材质的操作只会在客户端执行（实际上如果在服务端执行会出错），所以我们同时要在**`ClientProxy`的`preInit`阶段**中初始化：

**`src/main/java/com/github/ustc_zzzz/fmltutor/client/ClientProxy.java:`**

```java
package com.github.ustc_zzzz.fmltutor.client;

import com.github.ustc_zzzz.fmltutor.common.CommonProxy;

import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;

public class ClientProxy extends CommonProxy
{
    @Override
    public void preInit(FMLPreInitializationEvent event)
    {
        super.preInit(event);
        new ItemRenderLoader();
    }

    @Override
    public void init(FMLInitializationEvent event)
    {
        super.init(event);
    }

    @Override
    public void postInit(FMLPostInitializationEvent event)
    {
        super.postInit(event);
    }
}
```

在`com.github.ustc_zzzz.fmltutor.client`下新建`ItemRenderLoader`类：

**`src/main/java/com/github/ustc_zzzz/fmltutor/client/ItemRenderLoader.java:`**

```java
package com.github.ustc_zzzz.fmltutor.client;

import com.github.ustc_zzzz.fmltutor.item.ItemLoader;

public class ItemRenderLoader
{
    public ItemRenderLoader()
    {
        ItemLoader.registerRenders();
    }
}
```

现在在客户端，Forge会在`preInit`阶段，运行到`ItemRenderLoader`类的构造函数，进而运行到`ItemLoader`类中的`registerRenders`方法中的代码，也就是注册这个物品的渲染，而在服务端则不会运行。

现在运行游戏，你的手上是不是有了一个金色的蛋啦～

最后说一句，把所有只在客户端执行的代码放到同一个`client`文件夹下是一个好的习惯。
